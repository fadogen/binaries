name: "Build Garage"

on:
  schedule:
    - cron: '0 5 * * *'  # Daily at 5 AM UTC
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  check-garage-version:
    name: "Check Garage version"
    runs-on: ubuntu-latest
    outputs:
      should-build: ${{ steps.check.outputs.should-build }}
      garage-version: ${{ steps.check.outputs.garage-version }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Download metadata-garage.json from R2"
        id: download-metadata
        run: |
          if ! aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-garage.json metadata-garage.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "{}" > metadata-garage.json
            echo "Created empty metadata-garage.json"
          else
            echo "Downloaded existing metadata-garage.json"
          fi

      - name: "Check Garage version"
        id: check
        run: |
          # Fetch releases from Deuxfleurs API
          RELEASES_JSON=$(curl -fsSL --retry 3 --retry-delay 5 https://garagehq.deuxfleurs.fr/_releases.json)

          if [[ -z "$RELEASES_JSON" ]]; then
            echo "ERROR: Failed to fetch releases from Deuxfleurs API"
            exit 1
          fi

          # Extract latest stable release version from "Release" category
          LATEST_VERSION=$(echo "$RELEASES_JSON" | jq -r '.[] | select(.name == "Release") | .builds[0].version')

          # Validate we got a version
          if [[ -z "$LATEST_VERSION" || "$LATEST_VERSION" == "null" ]]; then
            echo "ERROR: Could not parse latest Garage version"
            exit 1
          fi

          # Remove 'v' prefix if present for consistency
          LATEST_VERSION="${LATEST_VERSION#v}"

          echo "Latest Garage version: $LATEST_VERSION"

          # Get version from metadata
          METADATA_VERSION=$(jq -r '.latest // ""' metadata-garage.json)
          echo "Metadata version: ${METADATA_VERSION:-none}"

          # Compare versions
          if [[ "$LATEST_VERSION" != "$METADATA_VERSION" ]]; then
            echo "should-build=true" >> $GITHUB_OUTPUT
            echo "garage-version=$LATEST_VERSION" >> $GITHUB_OUTPUT
            if [[ -z "$METADATA_VERSION" ]]; then
              echo "New: Garage $LATEST_VERSION (initial build)"
            else
              echo "Update: Garage $LATEST_VERSION (was: $METADATA_VERSION)"
            fi
          else
            echo "should-build=false" >> $GITHUB_OUTPUT
            echo "garage-version=$LATEST_VERSION" >> $GITHUB_OUTPUT
            echo "Garage $LATEST_VERSION already built, skipping"
          fi

  build-garage:
    name: "Build Garage ${{ needs.check-garage-version.outputs.garage-version }}"
    runs-on: macos-26
    needs: [check-garage-version]
    if: needs.check-garage-version.outputs.should-build == 'true'
    timeout-minutes: 60
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v6

      - name: "Install Rust toolchain"
        uses: dtolnay/rust-toolchain@stable

      - name: "Download and extract Garage source"
        run: |
          VERSION="${{ needs.check-garage-version.outputs.garage-version }}"
          GITEA_URL="https://git.deuxfleurs.fr/Deuxfleurs/garage/archive/v${VERSION}.tar.gz"
          GITHUB_URL="https://github.com/deuxfleurs-org/garage/archive/refs/tags/v${VERSION}.tar.gz"

          echo "Downloading Garage v${VERSION} source..."

          # Try Gitea first, fallback to GitHub mirror
          if curl -sSL --retry 2 --retry-delay 3 --max-time 60 -o "garage-source.tar.gz" "$GITEA_URL" && [[ -s "garage-source.tar.gz" ]]; then
            echo "Downloaded from Gitea"
            EXTRACTED_DIR="garage"
          elif curl -sSL --retry 2 --retry-delay 3 --max-time 120 -o "garage-source.tar.gz" "$GITHUB_URL" && [[ -s "garage-source.tar.gz" ]]; then
            echo "Downloaded from GitHub mirror"
            EXTRACTED_DIR="garage-${VERSION}"
          else
            echo "ERROR: Failed to download source from both Gitea and GitHub"
            exit 1
          fi

          echo "Extracting source..."
          tar -xzf "garage-source.tar.gz"
          mv "$EXTRACTED_DIR" garage-src

          echo "Source downloaded and extracted"

      - name: "Build Garage for macOS ARM64"
        run: |
          VERSION="${{ needs.check-garage-version.outputs.garage-version }}"

          cd garage-src

          echo "Building Garage ${VERSION} (release mode)..."
          echo "This may take several minutes..."

          # Build only the garage binary (not all workspace crates)
          cargo build --release -p garage

          # Verify binary was created
          if [[ ! -f "target/release/garage" ]]; then
            echo "ERROR: Binary not found at target/release/garage"
            exit 1
          fi

          # Verify architecture and size
          echo "Verifying binary..."
          file target/release/garage
          lipo -info target/release/garage
          ls -lh target/release/garage

          # Copy binary to workspace root
          cp target/release/garage "${GITHUB_WORKSPACE}/garage"

          echo "Build completed successfully"

      - name: "Import signing certificate"
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          echo "$BUILD_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          rm $RUNNER_TEMP/certificate.p12
          echo "Signing certificate imported"

      - name: "Sign Garage binary"
        env:
          SIGNING_IDENTITY: ${{ secrets.SIGNING_IDENTITY }}
        run: |
          echo "==> Signing Garage binary..."
          codesign --force --sign "$SIGNING_IDENTITY" --timestamp --options runtime \
            garage

          echo "==> Verifying signature..."
          codesign --verify --strict garage

          echo "Garage binary signed and verified"

      - name: "Create archive"
        run: |
          VERSION="${{ needs.check-garage-version.outputs.garage-version }}"
          ARCHIVE_NAME="garage-${VERSION}.tar.gz"

          # Make binary executable
          chmod +x garage

          # Create archive with just the binary at root
          tar -czf "$ARCHIVE_NAME" garage

          # Verify archive contents
          echo "Archive contents:"
          tar -tzf "$ARCHIVE_NAME"

          echo "Created $ARCHIVE_NAME"

      - name: "Upload archive to R2 with SHA-256 checksum"
        run: |
          VERSION="${{ needs.check-garage-version.outputs.garage-version }}"
          ARCHIVE_NAME="garage-${VERSION}.tar.gz"

          if [[ ! -f "$ARCHIVE_NAME" ]]; then
            echo "[ERROR] Archive not found: $ARCHIVE_NAME"
            exit 1
          fi

          # Upload with native SHA-256 checksum (R2 calculates and returns checksum)
          UPLOAD_RESULT=$(aws s3api put-object \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --key "$ARCHIVE_NAME" \
            --body "$ARCHIVE_NAME" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --checksum-algorithm SHA256 \
            --metadata tool="garage",version="$VERSION" \
            --output json)

          # Extract checksum from upload response and convert to hex
          CHECKSUM_BASE64=$(echo "$UPLOAD_RESULT" | jq -r '.ChecksumSHA256')
          CHECKSUM_HEX=$(echo "$CHECKSUM_BASE64" | base64 -d | xxd -p -c 256)

          echo "Uploaded $ARCHIVE_NAME (SHA-256: $CHECKSUM_HEX)"

          # Save checksum info (format: version,sha256,filename)
          echo "${VERSION},${CHECKSUM_HEX},${ARCHIVE_NAME}" > checksum-garage.txt

      - name: "Upload checksum info"
        uses: actions/upload-artifact@v6
        with:
          name: checksum-garage
          path: checksum-garage.txt
          retention-days: 1

  update-metadata:
    name: "Update metadata-garage.json"
    runs-on: ubuntu-latest
    needs: [check-garage-version, build-garage]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Download checksum artifact"
        uses: actions/download-artifact@v7
        with:
          name: checksum-garage

      - name: "Update metadata"
        run: |
          # Read checksum info (format: version,sha256,filename)
          IFS=',' read -r VERSION SHA256 FILENAME < checksum-garage.txt

          # Create metadata-garage.json
          jq -n \
            --arg latest "$VERSION" \
            --arg sha256 "$SHA256" \
            --arg filename "$FILENAME" \
            '{
              "latest": $latest,
              "sha256": $sha256,
              "filename": $filename
            }' > metadata-garage.json

          echo "Created metadata-garage.json:"
          cat metadata-garage.json

      - name: "Upload metadata-garage.json to R2"
        run: |
          aws s3 cp metadata-garage.json s3://${{ secrets.R2_BUCKET_NAME }}/metadata-garage.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null
          echo "Metadata updated"

  cleanup-old-builds:
    name: "Cleanup old Garage builds"
    runs-on: ubuntu-latest
    needs: [update-metadata]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Download updated metadata-garage.json from R2"
        run: |
          aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-garage.json metadata-garage.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null

      - name: "Cleanup old builds"
        run: |
          # Extract current filename from metadata
          CURRENT_FILENAME=$(jq -r '.filename' metadata-garage.json)

          echo "Current build: $CURRENT_FILENAME"

          # List all garage-*.tar.gz files and delete all except the current one
          aws s3api list-objects-v2 \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --prefix "garage-" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --query 'Contents[].Key' \
            --output text 2>/dev/null | tr '\t' '\n' | while read -r file_key; do
            case "$file_key" in
              garage-*.tar.gz)
                if [ "$file_key" != "$CURRENT_FILENAME" ] && [ -n "$file_key" ]; then
                  if aws s3 rm s3://${{ secrets.R2_BUCKET_NAME }}/"$file_key" --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null 2>&1; then
                    echo "Deleted old build: $file_key"
                  fi
                fi
                ;;
            esac
          done

          echo "Cleanup completed"
