name: "Build Typesense"

on:
  schedule:
    - cron: '0 4 * * *'  # Daily at 4 AM UTC
  workflow_dispatch:

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  check-typesense-version:
    name: "Check Typesense version"
    runs-on: ubuntu-latest
    outputs:
      should-build: ${{ steps.check.outputs.should-build }}
      typesense-version: ${{ steps.check.outputs.typesense-version }}
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v6

      - name: "Download metadata-typesense.json from R2"
        id: download-metadata
        run: |
          if ! aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-typesense.json metadata-typesense.json --endpoint-url ${{ secrets.R2_ENDPOINT }} 2>/dev/null; then
            echo "{}" > metadata-typesense.json
            echo "Created empty metadata-typesense.json"
          else
            echo "Downloaded existing metadata-typesense.json"
          fi

      - name: "Check Typesense version"
        id: check
        run: |
          # Fetch latest release from GitHub API (authenticated to avoid rate limits)
          LATEST_RELEASE=$(curl -fsSL -H "Authorization: Bearer $GITHUB_TOKEN" \
            https://api.github.com/repos/typesense/typesense/releases/latest)

          # Extract version (remove 'v' prefix if present)
          LATEST_VERSION=$(echo "$LATEST_RELEASE" | jq -r '.tag_name' | sed 's/^v//')

          echo "Latest Typesense version: $LATEST_VERSION"

          # Get version from metadata
          METADATA_VERSION=$(jq -r '.latest // ""' metadata-typesense.json)
          echo "Metadata version: ${METADATA_VERSION:-none}"

          # Compare versions
          if [[ "$LATEST_VERSION" != "$METADATA_VERSION" ]]; then
            echo "should-build=true" >> $GITHUB_OUTPUT
            echo "typesense-version=$LATEST_VERSION" >> $GITHUB_OUTPUT
            if [[ -z "$METADATA_VERSION" ]]; then
              echo "New: Typesense $LATEST_VERSION (initial build)"
            else
              echo "Update: Typesense $LATEST_VERSION (was: $METADATA_VERSION)"
            fi
          else
            echo "should-build=false" >> $GITHUB_OUTPUT
            echo "typesense-version=$LATEST_VERSION" >> $GITHUB_OUTPUT
            echo "Typesense $LATEST_VERSION already built, skipping"
          fi

  build-typesense:
    name: "Build Typesense ${{ needs.check-typesense-version.outputs.typesense-version }}"
    runs-on: macos-26
    needs: [check-typesense-version]
    if: needs.check-typesense-version.outputs.should-build == 'true'
    timeout-minutes: 30
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Checkout"
        uses: actions/checkout@v6

      - name: "Download and verify Typesense binary"
        run: |
          VERSION="${{ needs.check-typesense-version.outputs.typesense-version }}"
          DOWNLOAD_URL="https://dl.typesense.org/releases/${VERSION}/typesense-server-${VERSION}-darwin-arm64.tar.gz"

          echo "Downloading Typesense $VERSION..."
          curl -fsSL -o typesense.tar.gz "$DOWNLOAD_URL"

          echo "Extracting archive..."
          tar -xzf typesense.tar.gz

          # Verify MD5 checksum if provided
          if [[ -f "typesense-server.md5.txt" ]]; then
            EXPECTED_MD5=$(cat typesense-server.md5.txt | awk '{print $1}')
            ACTUAL_MD5=$(md5 -q typesense-server)

            if [[ "$EXPECTED_MD5" == "$ACTUAL_MD5" ]]; then
              echo "MD5 checksum verified: $ACTUAL_MD5"
            else
              echo "MD5 checksum mismatch!"
              echo "Expected: $EXPECTED_MD5"
              echo "Actual: $ACTUAL_MD5"
              exit 1
            fi
          else
            echo "No MD5 checksum file found, skipping verification"
          fi

          # Make executable
          chmod +x typesense-server

          echo "Typesense $VERSION downloaded and verified"

      - name: "Import signing certificate"
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          echo "$BUILD_CERTIFICATE_BASE64" | base64 --decode > $RUNNER_TEMP/certificate.p12
          security import $RUNNER_TEMP/certificate.p12 -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          rm $RUNNER_TEMP/certificate.p12
          echo "Signing certificate imported"

      - name: "Sign Typesense binary"
        env:
          SIGNING_IDENTITY: ${{ secrets.SIGNING_IDENTITY }}
        run: |
          echo "==> Signing Typesense server..."
          codesign --force --sign "$SIGNING_IDENTITY" --timestamp --options runtime \
            typesense-server

          echo "==> Verifying signature..."
          codesign --verify --strict typesense-server

          echo "Typesense binary signed and verified"

      - name: "Create archive"
        run: |
          VERSION="${{ needs.check-typesense-version.outputs.typesense-version }}"
          ARCHIVE_NAME="typesense-${VERSION}.tar.gz"

          # Create archive with just the binary at root
          tar -czf "$ARCHIVE_NAME" typesense-server

          echo "Created $ARCHIVE_NAME"

      - name: "Upload archive to R2 with SHA-256 checksum"
        run: |
          VERSION="${{ needs.check-typesense-version.outputs.typesense-version }}"
          ARCHIVE_NAME="typesense-${VERSION}.tar.gz"

          if [[ ! -f "$ARCHIVE_NAME" ]]; then
            echo "[ERROR] Archive not found: $ARCHIVE_NAME"
            exit 1
          fi

          # Upload with native SHA-256 checksum (R2 calculates and returns checksum)
          UPLOAD_RESULT=$(aws s3api put-object \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --key "$ARCHIVE_NAME" \
            --body "$ARCHIVE_NAME" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --checksum-algorithm SHA256 \
            --metadata tool="typesense",version="$VERSION" \
            --output json)

          # Extract checksum from upload response and convert to hex
          CHECKSUM_BASE64=$(echo "$UPLOAD_RESULT" | jq -r '.ChecksumSHA256')
          CHECKSUM_HEX=$(echo "$CHECKSUM_BASE64" | base64 -d | xxd -p -c 256)

          echo "Uploaded $ARCHIVE_NAME (SHA-256: $CHECKSUM_HEX)"

          # Save checksum info (format: version,sha256,filename)
          echo "${VERSION},${CHECKSUM_HEX},${ARCHIVE_NAME}" > checksum-typesense.txt

      - name: "Upload checksum info"
        uses: actions/upload-artifact@v6
        with:
          name: checksum-typesense
          path: checksum-typesense.txt
          retention-days: 1

  update-metadata:
    name: "Update metadata-typesense.json"
    runs-on: ubuntu-latest
    needs: [check-typesense-version, build-typesense]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Download checksum artifact"
        uses: actions/download-artifact@v7
        with:
          name: checksum-typesense

      - name: "Update metadata"
        run: |
          # Read checksum info (format: version,sha256,filename)
          IFS=',' read -r VERSION SHA256 FILENAME < checksum-typesense.txt

          # Create metadata-typesense.json
          jq -n \
            --arg latest "$VERSION" \
            --arg sha256 "$SHA256" \
            --arg filename "$FILENAME" \
            '{
              "latest": $latest,
              "sha256": $sha256,
              "filename": $filename
            }' > metadata-typesense.json

          echo "Created metadata-typesense.json:"
          cat metadata-typesense.json

      - name: "Upload metadata-typesense.json to R2"
        run: |
          aws s3 cp metadata-typesense.json s3://${{ secrets.R2_BUCKET_NAME }}/metadata-typesense.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null
          echo "Metadata updated"

  cleanup-old-builds:
    name: "Cleanup old Typesense builds"
    runs-on: ubuntu-latest
    needs: [update-metadata]
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
      AWS_DEFAULT_REGION: us-east-1
    steps:
      - name: "Download updated metadata-typesense.json from R2"
        run: |
          aws s3 cp s3://${{ secrets.R2_BUCKET_NAME }}/metadata-typesense.json metadata-typesense.json --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null

      - name: "Cleanup old builds"
        run: |
          # Extract current filename from metadata
          CURRENT_FILENAME=$(jq -r '.filename' metadata-typesense.json)

          echo "Current build: $CURRENT_FILENAME"

          # List all typesense-*.tar.gz files and delete all except the current one
          aws s3api list-objects-v2 \
            --bucket ${{ secrets.R2_BUCKET_NAME }} \
            --prefix "typesense-" \
            --endpoint-url ${{ secrets.R2_ENDPOINT }} \
            --query 'Contents[].Key' \
            --output text 2>/dev/null | tr '\t' '\n' | while read -r file_key; do
            case "$file_key" in
              typesense-*.tar.gz)
                if [ "$file_key" != "$CURRENT_FILENAME" ] && [ -n "$file_key" ]; then
                  if aws s3 rm s3://${{ secrets.R2_BUCKET_NAME }}/"$file_key" --endpoint-url ${{ secrets.R2_ENDPOINT }} >/dev/null 2>&1; then
                    echo "Deleted old build: $file_key"
                  fi
                fi
                ;;
            esac
          done

          echo "Cleanup completed"
